import { storage } from './storage';
import { SeoSetting, InsertSeoSetting } from '../shared/schema';

export interface BulkExportOptions {
  format: 'csv' | 'json';
  includeAutoGenerated?: boolean;
  filterByPage?: string[];
}

export interface BulkImportResult {
  success: boolean;
  imported: number;
  updated: number;
  errors: Array<{
    row: number;
    field: string;
    message: string;
  }>;
  summary: string;
}

export class BulkSEOOperations {
  
  async exportSeoSettings(options: BulkExportOptions): Promise<string> {
    try {
      const settings = await storage.getSeoSettings();
      
      // Filter settings if specified
      let filteredSettings = settings;
      if (options.filterByPage && options.filterByPage.length > 0) {
        filteredSettings = settings.filter(s => options.filterByPage!.includes(s.page));
      }

      // Prepare data for export
      const exportData = filteredSettings.map(setting => ({
        id: setting.id,
        page: setting.page,
        urlSlug: setting.urlSlug,
        metaTitle: setting.metaTitle || '',
        metaDescription: setting.metaDescription || '',
        robotsDirectives: setting.robotsDirectives || 'index,follow',
        canonicalUrl: setting.canonicalUrl || '',
        ogTitle: setting.ogTitle || '',
        ogDescription: setting.ogDescription || '',
        ogImageUrl: setting.ogImageUrl || '',
        twitterTitle: setting.twitterTitle || '',
        twitterDescription: setting.twitterDescription || '',
        twitterImageUrl: setting.twitterImageUrl || '',
        autoGenerateFaq: setting.autoGenerateFaq,
        autoGenerateVideos: setting.autoGenerateVideos,
        jsonLd: setting.jsonLd ? JSON.stringify(setting.jsonLd) : '',
        createdAt: setting.createdAt.toISOString(),
        updatedAt: setting.updatedAt.toISOString(),
      }));

      if (options.format === 'json') {
        return JSON.stringify(exportData, null, 2);
      } else {
        return this.convertToCSV(exportData);
      }
    } catch (error) {
      throw new Error(`Export failed: ${(error as Error).message}`);
    }
  }

  private convertToCSV(data: any[]): string {
    if (data.length === 0) {
      return '';
    }

    const headers = Object.keys(data[0]);
    const csvContent = [
      headers.join(','),
      ...data.map(row => 
        headers.map(header => {
          const value = row[header];
          // Escape commas and quotes in CSV
          if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
            return `"${value.replace(/"/g, '""')}"`;
          }
          return value;
        }).join(',')
      )
    ].join('\n');

    return csvContent;
  }

  async importSeoSettings(data: string, format: 'csv' | 'json'): Promise<BulkImportResult> {
    const result: BulkImportResult = {
      success: false,
      imported: 0,
      updated: 0,
      errors: [],
      summary: '',
    };

    try {
      let parsedData: any[];

      if (format === 'json') {
        parsedData = JSON.parse(data);
      } else {
        parsedData = this.parseCSV(data);
      }

      if (!Array.isArray(parsedData)) {
        throw new Error('Invalid data format: expected array');
      }

      // Get existing settings for comparison
      const existingSettings = await storage.getSeoSettings();
      const existingByPage = new Map(existingSettings.map(s => [`${s.page}-${s.urlSlug}`, s]));

      for (let i = 0; i < parsedData.length; i++) {
        const row = parsedData[i];
        
        try {
          const validatedSetting = this.validateSeoSetting(row, i);
          const pageKey = `${validatedSetting.page}-${validatedSetting.urlSlug}`;
          
          if (existingByPage.has(pageKey)) {
            // Update existing setting
            const existing = existingByPage.get(pageKey)!;
            await storage.updateSeoSetting(existing.id, validatedSetting);
            result.updated++;
          } else {
            // Create new setting
            await storage.createSeoSetting(validatedSetting);
            result.imported++;
          }
        } catch (error) {
          result.errors.push({
            row: i + 1,
            field: 'general',
            message: (error as Error).message,
          });
        }
      }

      result.success = result.errors.length < parsedData.length / 2; // Success if less than 50% errors
      result.summary = `Import completed: ${result.imported} new, ${result.updated} updated, ${result.errors.length} errors`;

      return result;
    } catch (error) {
      result.errors.push({
        row: 0,
        field: 'format',
        message: `Parse error: ${(error as Error).message}`,
      });
      result.summary = 'Import failed due to data format error';
      return result;
    }
  }

  private parseCSV(csvData: string): any[] {
    const lines = csvData.trim().split('\n');
    if (lines.length < 2) {
      throw new Error('CSV must have at least header and one data row');
    }

    const headers = lines[0].split(',').map(h => h.trim().replace(/^"(.*)"$/, '$1'));
    const data: any[] = [];

    for (let i = 1; i < lines.length; i++) {
      const values = this.parseCSVLine(lines[i]);
      if (values.length !== headers.length) {
        throw new Error(`Row ${i + 1}: column count mismatch`);
      }

      const row: any = {};
      headers.forEach((header, index) => {
        row[header] = values[index];
      });
      data.push(row);
    }

    return data;
  }

  private parseCSVLine(line: string): string[] {
    const values: string[] = [];
    let current = '';
    let inQuotes = false;
    let i = 0;

    while (i < line.length) {
      const char = line[i];
      
      if (char === '"') {
        if (inQuotes && line[i + 1] === '"') {
          // Escaped quote
          current += '"';
          i += 2;
        } else {
          // Toggle quote state
          inQuotes = !inQuotes;
          i++;
        }
      } else if (char === ',' && !inQuotes) {
        values.push(current.trim());
        current = '';
        i++;
      } else {
        current += char;
        i++;
      }
    }

    values.push(current.trim());
    return values;
  }

  private validateSeoSetting(data: any, rowIndex: number): InsertSeoSetting {
    const errors: string[] = [];

    // Required fields
    if (!data.page || typeof data.page !== 'string') {
      errors.push('page is required and must be a string');
    }

    if (!data.urlSlug || typeof data.urlSlug !== 'string') {
      errors.push('urlSlug is required and must be a string');
    }

    // Validate URL slug format
    if (data.urlSlug && !data.urlSlug.startsWith('/')) {
      errors.push('urlSlug must start with /');
    }

    // Validate meta title length
    if (data.metaTitle && data.metaTitle.length > 60) {
      errors.push('metaTitle should be 60 characters or less');
    }

    // Validate meta description length
    if (data.metaDescription && data.metaDescription.length > 160) {
      errors.push('metaDescription should be 160 characters or less');
    }

    // Validate URLs
    const urlFields = ['canonicalUrl', 'ogImageUrl', 'twitterImageUrl'];
    urlFields.forEach(field => {
      if (data[field] && data[field].trim()) {
        try {
          new URL(data[field]);
        } catch {
          errors.push(`${field} must be a valid URL`);
        }
      }
    });

    // Validate JSON-LD
    let jsonLd = null;
    if (data.jsonLd && data.jsonLd.trim()) {
      try {
        jsonLd = JSON.parse(data.jsonLd);
      } catch {
        errors.push('jsonLd must be valid JSON');
      }
    }

    // Validate boolean fields
    const booleanFields = ['autoGenerateFaq', 'autoGenerateVideos'];
    booleanFields.forEach(field => {
      if (data[field] !== undefined) {
        const value = data[field];
        if (typeof value === 'string') {
          data[field] = value.toLowerCase() === 'true';
        } else if (typeof value !== 'boolean') {
          errors.push(`${field} must be a boolean value`);
        }
      }
    });

    if (errors.length > 0) {
      throw new Error(`Row ${rowIndex + 1}: ${errors.join(', ')}`);
    }

    return {
      page: data.page.trim(),
      urlSlug: data.urlSlug.trim(),
      metaTitle: data.metaTitle?.trim() || null,
      metaDescription: data.metaDescription?.trim() || null,
      robotsDirectives: data.robotsDirectives?.trim() || 'index,follow',
      canonicalUrl: data.canonicalUrl?.trim() || null,
      ogTitle: data.ogTitle?.trim() || null,
      ogDescription: data.ogDescription?.trim() || null,
      ogImageUrl: data.ogImageUrl?.trim() || null,
      twitterTitle: data.twitterTitle?.trim() || null,
      twitterDescription: data.twitterDescription?.trim() || null,
      twitterImageUrl: data.twitterImageUrl?.trim() || null,
      jsonLd,
      autoGenerateFaq: data.autoGenerateFaq ?? false,
      autoGenerateVideos: data.autoGenerateVideos ?? false,
    };
  }

  async getExportStats(): Promise<{
    totalSettings: number;
    pageBreakdown: Record<string, number>;
    lastExportTime?: Date;
  }> {
    try {
      const settings = await storage.getSeoSettings();
      
      const pageBreakdown: Record<string, number> = {};
      settings.forEach(setting => {
        pageBreakdown[setting.page] = (pageBreakdown[setting.page] || 0) + 1;
      });

      return {
        totalSettings: settings.length,
        pageBreakdown,
      };
    } catch (error) {
      throw new Error(`Failed to get export stats: ${(error as Error).message}`);
    }
  }

  generateTemplate(format: 'csv' | 'json'): string {
    const template = {
      page: 'home',
      urlSlug: '/',
      metaTitle: 'Your Page Title (30-60 chars)',
      metaDescription: 'Your page description that appears in search results (120-160 chars)',
      robotsDirectives: 'index,follow',
      canonicalUrl: 'https://memopyk.com/',
      ogTitle: 'Social Media Title',
      ogDescription: 'Description for social media sharing',
      ogImageUrl: 'https://memopyk.com/og-image.jpg',
      twitterTitle: 'Twitter Card Title',
      twitterDescription: 'Description for Twitter cards',
      twitterImageUrl: 'https://memopyk.com/twitter-image.jpg',
      autoGenerateFaq: false,
      autoGenerateVideos: false,
      jsonLd: '{"@context":"https://schema.org","@type":"Organization","name":"MEMOPYK"}',
    };

    if (format === 'json') {
      return JSON.stringify([template], null, 2);
    } else {
      return this.convertToCSV([template]);
    }
  }
}

export const bulkSEOOperations = new BulkSEOOperations();